<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Corgi Bro's 0.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --corgi-body-color: #f7d188; /* Corgi fur */
            --corgi-white-color: #ffffff; /* Corgi belly/paws */
            --corgi-outline-color: #a07a3c; /* Darker outline */
            --platform-top-color: #6db64f; /* Green grass */
            --platform-side-color: #795548; /* Brown dirt/platform */
            --sky-color: #87ceeb; /* Light blue sky */
            --cloud-color: #ffffff;
            --ball-color: #a8c33c; /* Tennis ball green */
            --ball-line-color: #ffffff;
            --kibble-color: #b17e4f; /* Kibble brown */
            --kibble-shine-color: #e0b68e;
            --steak-meat-color: #e57373; /* Steak red */
            --steak-bone-color: #f5f5f5; /* Steak bone */
            --cat-body-color: #607D8B; /* Grumpy Cat grey */
            --cat-face-color: #455A64;
            --text-color: #212121;
        }

        body {
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #34495e;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border: 8px solid #f39c12;
        }

        #gameCanvas {
            border: 4px solid var(--text-color);
            background-color: var(--sky-color);
            border-radius: 8px;
            touch-action: none; /* Prevent browser gestures on canvas */
        }

        .hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            color: white;
            font-size: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .control-button, #startButton {
            color: #2c3e50;
            font-size: 14px;
            font-weight: bold;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            border: none;
            text-align: center;
            line-height: 1;
            min-width: 70px;
        }

        .control-button {
            background-color: #f39c12;
            box-shadow: 0 4px 0 #e67e22;
        }

        .control-button.jump {
            min-width: 100px;
        }

        .control-button.bite {
            background-color: #2ecc71; /* Green for attack */
            box-shadow: 0 4px 0 #27ae60;
        }

        .control-button:active, #startButton:active {
            transform: translateY(4px);
            box-shadow: 0 0px 0 #e67e22; /* Use specific shadow for consistency */
        }
        .control-button.bite:active {
            box-shadow: 0 0px 0 #27ae60;
        }


        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 10;
            color: white;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
        }

        .overlay h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #f39c12;
        }
        .overlay p {
            font-size: 10px;
            margin-bottom: 30px;
        }

        #startButton {
            background-color: #f39c12;
            box-shadow: 0 4px 0 #e67e22;
            font-size: 20px;
            padding: 15px 30px;
            min-width: 150px;
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 10px;
                width: 95%;
            }
            .hud {
                font-size: 8px;
            }
            .controls {
                gap: 8px;
            }
            .control-button {
                padding: 8px 12px;
                font-size: 12px;
                min-width: 60px;
            }
            .control-button.jump {
                min-width: 80px;
            }
            .overlay h1 {
                font-size: 18px;
            }
            #startButton {
                font-size: 16px;
                padding: 12px 25px;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <div id="startOverlay" class="overlay">
        <h1>Corgi Adventure</h1>
        <p>Collect Tennis Balls and Steaks while avoiding the Grumpy Cats!</p>
        <p>Controls: Arrow Keys/WASD to Move. **Z or K** or **BITE** button to Attack.</p>
        <button id="startButton">Start Game</button>
    </div>

    <div class="hud">
        <div id="scoreDisplay">TENNIS BALLS: 0</div>
        <div id="statusDisplay">STATUS: Little Corgi</div>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <button id="leftButton" class="control-button">&lt;</button>
        <button id="jumpButton" class="control-button jump">JUMP</button>
        <button id="biteButton" class="control-button bite">BITE</button>
        <button id="rightButton" class="control-button">&gt;</button>
    </div>
</div>

<script>
    // --- Global Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('startOverlay');
    const startButton = document.getElementById('startButton');

    const scoreDisplay = document.getElementById('scoreDisplay');
    const statusDisplay = document.getElementById('statusDisplay');

    const GRAVITY = 0.5;
    const GAME_SPEED = 4;
    const CAMERA_THRESHOLD = canvas.width / 3;

    let gameState = {
        score: 0,
        gameRunning: false,
        worldOffset: 0,
        keys: {},
        lastTimestamp: 0,
        isInvincible: false,
        invincibilityTimer: 0,
        kibbleTimer: 0,
        message: null,
        messageTimer: 0,
        timeLimit: 300,
        timeRemaining: 300,
        clouds: [],
        cloudScrollSpeed: 0.5,
    };

    function startGame() {
        if (!gameState.gameRunning) {
            startOverlay.style.display = 'none';
            init();
        }
    }


    // --- Utility Functions ---

    /**
     * Shows a temporary message on the screen.
     */
    function showMessage(text, duration = 120) {
        gameState.message = text;
        gameState.messageTimer = duration;
    }

    /**
     * Simplified AABB collision detection.
     */
    function checkCollision(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }

    // Helper to get CSS variable value
    function varToString(cssVar) {
        return getComputedStyle(document.body).getPropertyValue(cssVar).trim();
    }

    // --- Game Object Classes ---

    class Corgi {
        constructor(x, y) {
            this.initialX = x;
            this.initialY = y;
            this.x = x;
            this.y = y;
            
            // Default Little Corgi size constants
            this.LITTLE_WIDTH = 24;
            this.LITTLE_HEIGHT = 30;
            // Big Corgi size constants
            this.BIG_WIDTH = 32;
            this.BIG_HEIGHT = 40;

            // Default Little Corgi size
            this.width = this.LITTLE_WIDTH;
            this.height = this.LITTLE_HEIGHT;
            
            this.velY = 0;
            this.velX = 0;
            this.onGround = false;
            this.isBig = false;
            this.maxJumpVel = -10;

            // New attack properties
            this.isAttacking = false;
            this.attackTimer = 0;
            this.attackDuration = 10; // Frames for the bite
            this.attackHitbox = null; // Stores the active hitbox for collision
        }

        // Resets the Corgi's state for a new game or respawn
        reset() {
            this.x = this.initialX;
            this.y = this.initialY;
            this.velY = 0;
            this.velX = 0;
            this.isBig = false;
            gameState.isInvincible = false;
            gameState.invincibilityTimer = 0;
            gameState.kibbleTimer = 0;
            // Reset to default size
            this.height = this.LITTLE_HEIGHT;
            this.width = this.LITTLE_WIDTH;
        }

        // Handles the Kibble power-up
        grow() {
            if (!this.isBig) {
                const oldHeight = this.height; // Should be 30
                
                // Set new size
                this.height = this.BIG_HEIGHT; // 40
                this.width = this.BIG_WIDTH;   // 32
                
                // Adjust position: Move Corgi up by the height difference to keep feet on the ground.
                this.y -= (this.height - oldHeight); 

                this.isBig = true;
                gameState.kibbleTimer = 600;
            }
        }

        // Handles the Steak power-up (Invincibility)
        activateSteak() {
            gameState.isInvincible = true;
            gameState.invincibilityTimer = 600;
        }

        // New bite attack method
        bite() {
            if (!this.isAttacking && gameState.gameRunning) {
                this.isAttacking = true;
                this.attackTimer = this.attackDuration;
            }
        }

        // Handle hit/damage
        hit() {
            if (gameState.isInvincible) return;

            if (this.isBig) {
                // If big, shrink
                const oldHeight = this.height; // Should be 40

                this.height = this.LITTLE_HEIGHT; // 30
                this.width = this.LITTLE_WIDTH;   // 24
                
                // Adjust position: Move Corgi down by the height difference to keep feet on the ground.
                this.y += (oldHeight - this.height); 

                this.isBig = false;
                gameState.kibbleTimer = 0;
                showMessage("OUCH! Back to Little Corgi.");
            } else {
                // If small, Game Over
                gameOver();
            }
        }

        update() {
            // Apply gravity
            this.velY += GRAVITY;
            this.y += this.velY;
            this.onGround = false;

            // Handle horizontal movement based on key state
            this.velX = 0;
            if (gameState.keys['ArrowLeft'] || gameState.keys['A']) {
                this.velX = -GAME_SPEED;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['D']) {
                this.velX = GAME_SPEED;
            }
            this.x += this.velX;

            // Handle Kibble Timer (Big Corgi) - Shrinks when time runs out, regardless of invincibility
            if (this.isBig) {
                gameState.kibbleTimer--;
                if (gameState.kibbleTimer <= 0) {
                    // Shrink visually
                    const oldHeight = this.height; 
                    this.height = this.LITTLE_HEIGHT; 
                    this.width = this.LITTLE_WIDTH;
                    this.y += (oldHeight - this.height); 
                    this.isBig = false;
                    gameState.kibbleTimer = 0;
                    showMessage("Little Corgi again!");
                }
            }

            // Handle Invincibility Timer (Steak Power)
            if (gameState.isInvincible) {
                gameState.invincibilityTimer--;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                }
            }
            
            // Handle Attack Timer
            if (this.isAttacking) {
                this.attackTimer--;
                if (this.attackTimer <= 0) {
                    this.isAttacking = false;
                    this.attackHitbox = null; // Clear hitbox
                }
            }


            // Camera movement logic
            if (this.x - gameState.worldOffset > CAMERA_THRESHOLD) {
                gameState.worldOffset = this.x - CAMERA_THRESHOLD;
            }
        }

        jump() {
            if (this.onGround) {
                this.velY = this.maxJumpVel;
                this.onGround = false;
            }
        }

        draw() {
            const displayX = this.x - gameState.worldOffset;
            const bodyColor = varToString('--corgi-body-color');
            const whiteColor = varToString('--corgi-white-color');
            const outlineColor = varToString('--corgi-outline-color');

            // Invincibility flash effect
            if (gameState.isInvincible && Math.floor(gameState.invincibilityTimer / 10) % 2 === 0) {
                 ctx.fillStyle = 'yellow';
                 ctx.fillRect(displayX - 4, this.y - 4, this.width + 8, this.height + 8);
            }

            // Corgi outline
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            // --- DRAW CORGI BODY ---
            ctx.beginPath();
            if (this.isBig) {
                // Big Corgi (Width 32, Height 40)
                // Body
                ctx.rect(displayX, this.y + 10, this.width, this.height - 10);
                // Head
                ctx.rect(displayX + this.width / 4, this.y, this.width / 2, 12);
                // Ears
                ctx.moveTo(displayX + this.width / 4 + 2, this.y);
                ctx.lineTo(displayX + this.width / 4 + 8, this.y - 8);
                ctx.lineTo(displayX + this.width / 4 + 14, this.y);

                ctx.moveTo(displayX + this.width - this.width / 4 - 2, this.y);
                ctx.lineTo(displayX + this.width - this.width / 4 - 8, this.y - 8);
                ctx.lineTo(displayX + this.width - this.width / 4 - 14, this.y);

                // Tail
                ctx.moveTo(displayX + this.width, this.y + 25);
                ctx.lineTo(displayX + this.width + 8, this.y + 20);
                ctx.lineTo(displayX + this.width + 4, this.y + 30);
            } else {
                // Little Corgi (Width 24, Height 30)
                // Body
                ctx.rect(displayX, this.y + 5, this.width, this.height - 5);
                // Head
                ctx.rect(displayX + this.width / 4, this.y, this.width / 2, 8);
                // Ears
                ctx.moveTo(displayX + this.width / 4 + 1, this.y);
                ctx.lineTo(displayX + this.width / 4 + 5, this.y - 5);
                ctx.lineTo(displayX + this.width / 4 + 9, this.y);

                ctx.moveTo(displayX + this.width - this.width / 4 - 1, this.y);
                ctx.lineTo(displayX + this.width - this.width / 4 - 5, this.y - 5);
                ctx.lineTo(displayX + this.width - this.width / 4 - 9, this.y);

                // Tail
                ctx.moveTo(displayX + this.width, this.y + 15);
                ctx.lineTo(displayX + this.width + 4, this.y + 12);
                ctx.lineTo(displayX + this.width + 1, this.y + 18);
            }
            ctx.closePath();
            ctx.stroke(); // Draw outline

            // Fill Corgi body
            ctx.fillStyle = bodyColor;
            if (this.isBig) {
                ctx.fillRect(displayX, this.y + 10, this.width, this.height - 10); // Body
                ctx.fillRect(displayX + this.width / 4, this.y, this.width / 2, 12); // Head
            } else {
                ctx.fillRect(displayX, this.y + 5, this.width, this.height - 5); // Body
                ctx.fillRect(displayX + this.width / 4, this.y, this.width / 2, 8); // Head
            }

            // White belly/paws
            ctx.fillStyle = whiteColor;
            if (this.isBig) {
                ctx.fillRect(displayX + 4, this.y + this.height - 8, this.width - 8, 8);
                ctx.fillRect(displayX + this.width / 4 + 2, this.y + 8, this.width / 2 - 4, 4); // Snout
            } else {
                ctx.fillRect(displayX + 3, this.y + this.height - 6, this.width - 6, 6);
                ctx.fillRect(displayX + this.width / 4 + 1, this.y + 5, this.width / 2 - 2, 3); // Snout
            }


            // Ears (filled) and Tail (filled) - Simplified
            ctx.fillStyle = bodyColor;
            
            // Redraw ears and tails as filled shapes
            const drawFilledShape = (pathFunc) => {
                ctx.beginPath();
                pathFunc();
                ctx.fill();
            };

            if (this.isBig) {
                drawFilledShape(() => {
                    ctx.moveTo(displayX + this.width / 4 + 2, this.y);
                    ctx.lineTo(displayX + this.width / 4 + 8, this.y - 8);
                    ctx.lineTo(displayX + this.width / 4 + 14, this.y);
                });
                drawFilledShape(() => {
                    ctx.moveTo(displayX + this.width - this.width / 4 - 2, this.y);
                    ctx.lineTo(displayX + this.width - this.width / 4 - 8, this.y - 8);
                    ctx.lineTo(displayX + this.width - this.width / 4 - 14, this.y);
                });
                 drawFilledShape(() => {
                    ctx.moveTo(displayX + this.width, this.y + 25);
                    ctx.lineTo(displayX + this.width + 8, this.y + 20);
                    ctx.lineTo(displayX + this.width + 4, this.y + 30);
                });
            } else {
                drawFilledShape(() => {
                    ctx.moveTo(displayX + this.width / 4 + 1, this.y);
                    ctx.lineTo(displayX + this.width / 4 + 5, this.y - 5);
                    ctx.lineTo(displayX + this.width / 4 + 9, this.y);
                });
                drawFilledShape(() => {
                    ctx.moveTo(displayX + this.width - this.width / 4 - 1, this.y);
                    ctx.lineTo(displayX + this.width - this.width / 4 - 5, this.y - 5);
                    ctx.lineTo(displayX + this.width - this.width / 4 - 9, this.y);
                });
                drawFilledShape(() => {
                    ctx.moveTo(displayX + this.width, this.y + 15);
                    ctx.lineTo(displayX + this.width + 4, this.y + 12);
                    ctx.lineTo(displayX + this.width + 1, this.y + 18);
                });
            }


            // --- DRAW BITE ATTACK HITBOX (Visual Indicator) ---
            if (this.isAttacking) {
                let attackWidth = 10;
                let attackHeight = 10;
                let attackOffsetX = this.width;

                // Simple mouth chomp effect at the front
                ctx.fillStyle = 'rgba(231, 76, 60, 0.9)'; // Red for bite
                ctx.fillRect(displayX + attackOffsetX, this.y + this.height/2 - 5, attackWidth, attackHeight);

                // Store the attack hitbox for collision calculation
                this.attackHitbox = {
                    x: this.x + attackOffsetX,
                    y: this.y + this.height/2 - 5,
                    width: attackWidth,
                    height: attackHeight
                };
            } else {
                this.attackHitbox = null;
            }
            
            // Reset line width for other elements
            ctx.lineWidth = 1;
        }
    }

    class Platform {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        draw() {
            const displayX = this.x - gameState.worldOffset;
            if (displayX + this.width < 0 || displayX > canvas.width) return;

            const topColor = varToString('--platform-top-color');
            const sideColor = varToString('--platform-side-color');

            // Draw the side/depth effect
            ctx.fillStyle = sideColor;
            ctx.fillRect(displayX, this.y + 4, this.width, this.height - 4);

            // Draw the top surface (grass)
            ctx.fillStyle = topColor;
            ctx.fillRect(displayX, this.y, this.width, 10); // Thicker top for grass effect

            // Outline for a cleaner look
            ctx.strokeStyle = '#4A322B'; // Darker brown
            ctx.lineWidth = 2;
            ctx.strokeRect(displayX, this.y, this.width, this.height);
            ctx.lineWidth = 1; // Reset
        }
    }

    class Item {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type; // 'ball', 'kibble', 'steak'
            this.width = 16;
            this.height = 16;
            this.collected = false;
        }

        draw() {
            if (this.collected) return;
            const displayX = this.x - gameState.worldOffset;
            if (displayX + this.width < 0 || displayX > canvas.width) return;

            if (this.type === 'ball') {
                // Tennis Ball (Green Circle with white lines)
                ctx.fillStyle = varToString('--ball-color');
                ctx.beginPath();
                ctx.arc(displayX + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = varToString('--ball-line-color');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(displayX + this.width / 2, this.y + this.height / 2, this.width / 2 - 1, Math.PI * 0.75, Math.PI * 0.25);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(displayX + this.width / 2, this.y + this.height / 2, this.width / 2 - 1, Math.PI * 1.75, Math.PI * 1.25);
                ctx.stroke();
                ctx.lineWidth = 1;

            } else if (this.type === 'kibble') {
                // Kibble (Brown Hexagon/Diamond-like shape)
                ctx.fillStyle = varToString('--kibble-color');
                ctx.beginPath();
                ctx.moveTo(displayX + this.width / 2, this.y);
                ctx.lineTo(displayX + this.width, this.y + this.height / 3);
                ctx.lineTo(displayX + this.width, this.y + this.height * 2 / 3);
                ctx.lineTo(displayX + this.width / 2, this.y + this.height);
                ctx.lineTo(displayX, this.y + this.height * 2 / 3);
                ctx.lineTo(displayX, this.y + this.height / 3);
                ctx.closePath();
                ctx.fill();

                // Shine
                ctx.fillStyle = varToString('--kibble-shine-color');
                ctx.beginPath();
                ctx.moveTo(displayX + this.width * 0.3, this.y + this.height * 0.3);
                ctx.lineTo(displayX + this.width * 0.5, this.y + this.height * 0.2);
                ctx.lineTo(displayX + this.width * 0.7, this.y + this.height * 0.3);
                ctx.fill();

            } else if (this.type === 'steak') {
                // Steak (Red Icon/Shape with bone)
                ctx.fillStyle = varToString('--steak-meat-color');
                ctx.beginPath();
                // Meat part
                ctx.moveTo(displayX, this.y + this.height / 2);
                ctx.bezierCurveTo(displayX, this.y, displayX + this.width * 0.8, this.y, displayX + this.width, this.y + this.height / 4);
                ctx.bezierCurveTo(displayX + this.width * 0.8, this.y + this.height, displayX, this.y + this.height, displayX, this.y + this.height / 2);
                ctx.fill();

                // Bone part
                ctx.fillStyle = varToString('--steak-bone-color');
                ctx.beginPath();
                ctx.ellipse(displayX + this.width * 0.8, this.y + this.height * 0.15, this.width * 0.15, this.height * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(displayX + this.width * 0.8, this.y + this.height * 0.85, this.width * 0.15, this.height * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillRect(displayX + this.width * 0.8 - 3, this.y + this.height * 0.15, 6, this.height * 0.7);
            }
        }
    }

    class Enemy {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 30;
            this.height = 30;
            this.velX = 1.5;
            this.alive = true;
            this.initialX = x; // For patrol boundaries
        }

        update(platforms) {
            if (!this.alive) return;

            // Simple movement and boundary check
            this.x += this.velX;

            // Get the platform directly below the enemy's next position
            const nextX = this.x + this.velX;
            const groundY = this.y + this.height;

            let foundPlatform = false;
            for (const p of platforms) {
                 // Check if the enemy's feet (groundY) are on or slightly below the platform's top
                if (p.x <= nextX && p.x + p.width >= nextX + this.width && p.y >= groundY - 2 && p.y <= groundY + 2) {
                    foundPlatform = true;
                    break;
                }
            }

            // Reverse direction if hitting an edge or falling off a platform (simplified)
            // or if no platform is found ahead, reverse direction
            if (!foundPlatform || Math.abs(this.x - this.initialX) > 200) { // Patrol range of 200 units
                 this.velX *= -1;
                 this.initialX = this.x; // Reset initialX after reversing for next patrol
            }
        }

        draw() {
            if (!this.alive) return;
            const displayX = this.x - gameState.worldOffset;
            if (displayX + this.width < 0 || displayX > canvas.width) return;

            const catBodyColor = varToString('--cat-body-color');
            const catFaceColor = varToString('--cat-face-color');

            // Body
            ctx.fillStyle = catBodyColor;
            ctx.fillRect(displayX, this.y + 5, this.width, this.height - 5);

            // Head
            ctx.fillRect(displayX + this.width / 4, this.y, this.width / 2, 10);

            // Ears
            ctx.beginPath();
            ctx.moveTo(displayX + this.width / 4, this.y);
            ctx.lineTo(displayX + this.width / 4 + 5, this.y - 8);
            ctx.lineTo(displayX + this.width / 2 - 2, this.y);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(displayX + this.width - this.width / 4, this.y);
            ctx.lineTo(displayX + this.width - this.width / 4 - 5, this.y - 8);
            ctx.lineTo(displayX + this.width / 2 + 2, this.y);
            ctx.fill();

            // Face details (eyes, nose, mouth)
            ctx.fillStyle = catFaceColor;
            ctx.fillRect(displayX + this.width * 0.3, this.y + 3, 4, 4); // Left eye
            ctx.fillRect(displayX + this.width * 0.7 - 4, this.y + 3, 4, 4); // Right eye

            ctx.fillRect(displayX + this.width / 2 - 2, this.y + 8, 4, 2); // Nose

            // Whiskers (simplified lines)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(displayX + this.width / 2 - 8, this.y + 10); ctx.lineTo(displayX + this.width / 2 - 2, this.y + 9);
            ctx.moveTo(displayX + this.width / 2 - 8, this.y + 12); ctx.lineTo(displayX + this.width / 2 - 2, this.y + 11);

            ctx.moveTo(displayX + this.width / 2 + 8, this.y + 10); ctx.lineTo(displayX + this.width / 2 + 2, this.y + 9);
            ctx.moveTo(displayX + this.width / 2 + 8, this.y + 12); ctx.lineTo(displayX + this.width / 2 + 2, this.y + 11);
            ctx.stroke();

        }
    }

    class Cloud {
        constructor(x, y, width, height, speed) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.speed = speed;
        }

        update() {
            this.x -= this.speed;
            if (this.x + this.width < 0) {
                this.x = canvas.width + Math.random() * 200; // Reset off-screen to the right
                this.y = Math.random() * (canvas.height / 2 - 50); // Random Y in upper half
            }
        }

        draw() {
            ctx.fillStyle = varToString('--cloud-color');
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.width / 3, 0, Math.PI * 2);
            ctx.arc(this.x + this.width * 0.4, this.y - this.height * 0.2, this.width / 3.5, 0, Math.PI * 2);
            ctx.arc(this.x + this.width * 0.7, this.y + this.height * 0.1, this.width / 3, 0, Math.PI * 2);
            ctx.arc(this.x + this.width * 0.3, this.y + this.height * 0.3, this.width / 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }


    // --- Game World Data ---
    let corgi;
    let platforms = [];
    let items = [];
    let enemies = [];

    function setupWorld() {
        platforms = [];
        items = [];
        enemies = [];
        gameState.worldOffset = 0;
        gameState.score = 0;
        gameState.timeRemaining = gameState.timeLimit;

        // Generate clouds
        gameState.clouds = [];
        for (let i = 0; i < 5; i++) {
            gameState.clouds.push(new Cloud(
                Math.random() * canvas.width,
                Math.random() * (canvas.height / 2 - 50),
                50 + Math.random() * 70,
                30 + Math.random() * 40,
                0.2 + Math.random() * 0.3
            ));
        }


        // Platform: Ground Level (covers the entire bottom of the screen)
        platforms.push(new Platform(0, canvas.height - 20, 3000, 20));

        // Platform: Starting platform (extra long)
        platforms.push(new Platform(0, canvas.height - 20, 200, 20));

        // Platforms (x, y, width, height)
        platforms.push(new Platform(250, canvas.height - 80, 100, 20));
        platforms.push(new Platform(450, canvas.height - 140, 150, 20));
        platforms.push(new Platform(700, canvas.height - 100, 50, 20));
        platforms.push(new Platform(800, canvas.height - 200, 100, 20));
        platforms.push(new Platform(1000, canvas.height - 250, 200, 20));
        platforms.push(new Platform(1300, canvas.height - 150, 100, 20));
        platforms.push(new Platform(1600, canvas.height - 80, 50, 20));
        platforms.push(new Platform(1800, canvas.height - 200, 300, 20));
        platforms.push(new Platform(2300, canvas.height - 200, 50, 20));
        platforms.push(new Platform(2500, canvas.height - 100, 200, 20));

        // Items (x, y, type)
        // Tennis Balls (Score)
        items.push(new Item(100, canvas.height - 50, 'ball'));
        items.push(new Item(270, canvas.height - 110, 'ball'));
        items.push(new Item(490, canvas.height - 170, 'ball'));
        items.push(new Item(510, canvas.height - 170, 'ball'));
        items.push(new Item(710, canvas.height - 130, 'ball'));
        items.push(new Item(820, canvas.height - 230, 'ball'));
        items.push(new Item(1050, canvas.height - 280, 'ball'));
        items.push(new Item(1080, canvas.height - 280, 'ball'));
        items.push(new Item(1350, canvas.height - 180, 'ball'));

        // Kibble (Mushroom/Grow)
        items.push(new Item(300, canvas.height - 110, 'kibble'));
        items.push(new Item(1050, canvas.height - 200, 'kibble'));

        // Steak (Star/Invincibility)
        items.push(new Item(600, canvas.height - 250, 'steak'));
        items.push(new Item(1950, canvas.height - 230, 'steak'));

        // Enemies (x, y) - Grumpy Cat
        enemies.push(new Enemy(500, canvas.height - 170 - 30));
        enemies.push(new Enemy(1100, canvas.height - 280 - 30));
        enemies.push(new Enemy(2000, canvas.height - 230 - 30));

        // Final goal marker
        platforms.push(new Platform(2800, canvas.height - 200, 20, 180));
    }

    function init() {
        corgi = new Corgi(50, canvas.height - 20 - corgi.LITTLE_HEIGHT);
        setupWorld();
        gameState.gameRunning = true;
        showMessage("Corgi Adventure! Get the Steak!", 180);
        window.requestAnimationFrame(gameLoop);
    }

    // --- Game Logic ---

    function updateGame(deltaTime) {
        if (!gameState.gameRunning) return;

        // Decrease timer
        gameState.timeRemaining -= deltaTime / 1000;
        if (gameState.timeRemaining <= 0) {
            gameOver();
            return;
        }


        // 1. Update Corgi
        corgi.update();

        // 2. Update Enemies
        enemies.forEach(e => e.update(platforms));

        // 3. Handle Corgi-Platform Collision
        let lastOnGround = corgi.onGround;
        corgi.onGround = false;

        for (const p of platforms) {
            if (checkCollision(corgi, p)) {
                // Determine collision direction
                const hitBottom = corgi.y + corgi.height < p.y + p.height && corgi.y + corgi.height > p.y;
                // const hitTop = corgi.y > p.y && corgi.y < p.y + p.height; // Not strictly needed

                if (hitBottom && corgi.velY >= 0) {
                    // Corgi's head hits a block from below (can still happen if big)
                    // (Silent version)
                }

                if (corgi.velY > 0 && corgi.y + corgi.height <= p.y + corgi.velY + 1) {
                    // Landed on top of a platform
                    corgi.y = p.y - corgi.height;
                    corgi.velY = 0;
                    corgi.onGround = true;
                } else if (corgi.velY < 0 && corgi.y < p.y + p.height && corgi.y + corgi.height > p.y) {
                    // Hitting a platform from below
                    corgi.velY = 0;
                    corgi.y = p.y + p.height;
                } else if (corgi.velX !== 0) {
                    // Horizontal collision (simple stop)
                    if (corgi.x < p.x) {
                        corgi.x = p.x - corgi.width;
                    } else {
                        corgi.x = p.x + p.width;
                    }
                }
            }
        }

        // 4. Handle Item Collection
        items.forEach(item => {
            if (!item.collected && checkCollision(corgi, item)) {
                item.collected = true;

                if (item.type === 'ball') {
                    gameState.score += 10;
                    showMessage("+10 Tennis Balls!");
                } else if (item.type === 'kibble') {
                    corgi.grow();
                    showMessage("KIBBLE! Big Corgi Power!");
                } else if (item.type === 'steak') {
                    corgi.activateSteak();
                    showMessage("STEAK! Invincibility!");
                }
            }
        });

        // 5. Handle Corgi-Enemy Interaction
        enemies.forEach(enemy => {
            if (!enemy.alive) return; // Skip dead enemies

            // Check for BITE ATTACK
            if (corgi.isAttacking && corgi.attackHitbox && checkCollision(corgi.attackHitbox, enemy)) {
                enemy.alive = false;
                gameState.score += 250;
                showMessage("CRUNCH! +250 BITE BONUS!");
                return; // Enemy is dead, skip remaining checks for this enemy in this iteration.
            }

            // Check for Stomp or Contact Damage (Only check if Corgi hasn't taken damage yet this frame)
            if (checkCollision(corgi, enemy)) {
                // Check for stomp
                if (corgi.velY > 0 && corgi.y + corgi.height - corgi.velY < enemy.y + 5) {
                    // Stomp!
                    enemy.alive = false;
                    corgi.velY = corgi.maxJumpVel / 2; // Small bounce
                    gameState.score += 100;
                    showMessage("Stomp! +100");
                } else {
                    // Hit from side or bottom
                    corgi.hit();
                }
            }
        });
        
        // CRITICAL FIX: Filter out enemies marked as dead. This prevents dead entities from causing 
        // collision issues in subsequent frames and removes the 'break the game' issue.
        enemies = enemies.filter(e => e.alive);


        // 6. Check for Win/Lose conditions
        if (corgi.x > 2800) { // Past the goal
            gameWin();
        }

        if (corgi.y > canvas.height + 50) {
            // Fell off the bottom of the world
            gameOver();
        }

        // Update clouds for parallax effect
        gameState.clouds.forEach(cloud => cloud.update());

        // 7. Update HUD
        scoreDisplay.textContent = `TENNIS BALLS: ${gameState.score}`;
        let statusText = corgi.isBig ? 'Big Corgi' : 'Little Corgi';
        if (gameState.isInvincible) {
            statusText = `Steak Power! (${Math.ceil(gameState.invincibilityTimer / 60)}s)`;
        } else if (corgi.isBig) {
            statusText += ` (${Math.ceil(gameState.kibbleTimer / 60)}s)`
        }
        statusDisplay.textContent = `STATUS: ${statusText} | TIME: ${Math.ceil(gameState.timeRemaining)}`;

        // 8. Update Message Timer
        if (gameState.messageTimer > 0) {
            gameState.messageTimer--;
        }
    }

    function drawGame() {
        // Clear canvas
        ctx.fillStyle = varToString('--sky-color');
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw parallax clouds
        gameState.clouds.forEach(cloud => cloud.draw());

        // Draw Platforms
        platforms.forEach(p => p.draw());

        // Draw Items
        items.forEach(i => i.draw());

        // Draw Enemies
        enemies.forEach(e => e.draw());

        // Draw Corgi
        corgi.draw();

        // Draw temporary message
        if (gameState.messageTimer > 0 && gameState.message) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height / 2 - 25, canvas.width, 50);
            ctx.fillStyle = 'white';
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.message, canvas.width / 2, canvas.height / 2 + 5);
        }
    }

    function gameLoop(timestamp) {
        if (!gameState.gameRunning) return;

        const deltaTime = timestamp - gameState.lastTimestamp;
        gameState.lastTimestamp = timestamp;

        // Ensure a relatively stable framerate (approx 60fps)
        if (deltaTime < 20) {
            updateGame(deltaTime);
            drawGame();
        } else {
             // If a large delta occurs (e.g., tab switch), skip update but redraw
             drawGame();
        }

        window.requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        gameState.gameRunning = false;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'red';
        ctx.font = '30px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText(`Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Press R to Retry', canvas.width / 2, canvas.height / 2 + 60);
    }

    function gameWin() {
        gameState.gameRunning = false;
        
        ctx.fillStyle = 'rgba(0, 100, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'lightgreen';
        ctx.font = '30px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2 - 20);
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Press R for a New Walk', canvas.width / 2, canvas.height / 2 + 60);
    }

    // --- Input Handling ---

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
            e.preventDefault();
            if (gameState.gameRunning) corgi.jump();
        }
        
        // New Bite Attack Key (Z or K)
        if (e.code === 'KeyZ' || e.code === 'KeyK') {
            e.preventDefault();
            if (gameState.gameRunning) corgi.bite();
        }

        if (e.code === 'KeyR' && !gameState.gameRunning) {
            startGame(); // Retry game
        }
        gameState.keys[e.code] = true;
    });

    document.addEventListener('keyup', (e) => {
        gameState.keys[e.code] = false;
    });

    // Touch/Button controls

    // Reusable handler for movement buttons
    const setupMovementButton = (id, key) => {
        const button = document.getElementById(id);
        button.addEventListener('mousedown', (e) => { e.preventDefault(); gameState.keys[key] = true; });
        button.addEventListener('mouseup', (e) => { e.preventDefault(); gameState.keys[key] = false; });
        button.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.keys[key] = true; });
        button.addEventListener('touchend', (e) => { e.preventDefault(); gameState.keys[key] = false; });
    };

    setupMovementButton('leftButton', 'ArrowLeft');
    setupMovementButton('rightButton', 'ArrowRight');

    document.getElementById('jumpButton').addEventListener('mousedown', (e) => { e.preventDefault(); if (gameState.gameRunning) corgi.jump(); });
    document.getElementById('jumpButton').addEventListener('touchstart', (e) => { e.preventDefault(); if (gameState.gameRunning) corgi.jump(); });
    
    // New Bite Button Listener
    document.getElementById('biteButton').addEventListener('mousedown', (e) => { e.preventDefault(); if (gameState.gameRunning) corgi.bite(); });
    document.getElementById('biteButton').addEventListener('touchstart', (e) => { e.preventDefault(); if (gameState.gameRunning) corgi.bite(); });

    // Initial setup and Start Button listener
    window.onload = function() {
        corgi = new Corgi(50, canvas.height - 20 - 30);
        setupWorld();
        
        startButton.addEventListener('click', startGame);
        startButton.addEventListener('touchend', startGame);
    };

</script>

</body>
</html>